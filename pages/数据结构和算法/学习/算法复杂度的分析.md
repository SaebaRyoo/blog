# 算法复杂度的分析

> 算法的目的就是“快”和“省”。即如何让代码执行的更快，如何让代码更省内存空间


复杂度分析就是为了让**测试结果脱离测试环境，脱离测试数据。能够粗略的估算算法的执行效率**

### 大O表示法
所有代码的执行时间T(n)与每行代码的执行次数n成正比， 总结为规律就是`T(n)= O( f(n) )`。T(n)表示代码执行时间。f(n)表示代码执行次数，因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

如下，cal函数的算法复杂度就为`T(n) = O(2+2n)`, cal1为`T(n) = O(3n+2n+2n²)`
```javascript
    function cal(n) {
        var sum = 0;
        var i = 1;
        for (; i < n; i++) {
            sum = sum + i;
        }
        return sum;
    }

    
    function cal1(n) {
        var sum = 0;
        var i = 1;
        var j = 1;
        for (; i <= n; ++i) {
            j = 1;
            for (; j <= n; ++j) {
                sum = sum +  i * j;
            }
        }
    }
```

大O时间表示法并不代表代码的具体执行时间，而是 **<u>代码的执行时间随着数据规模增长的变化趋势</u>**, 又叫**渐进时间复杂度**。简称**时间复杂度**。

在上面的公式中，当n很大时。**低阶、常量、系数并不左右增长趋势，都可以忽略** 。只需要记录一个最大量级。比如上面的cal为`T(n) = O(n)` cal1为`T(n) = O(n²)`


### 加法法则:总复杂度等于最大量级的代码
> 如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))
### 乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
> 如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).


### 最好、最坏、平均、均摊时间复杂度

**最好时间复杂度就是，在最理想情况下，执行这个算法的消耗时间**， 如在一个数组中查找一个元素，这个元素正好在第一个 
**最坏时间复杂度则是，在糟糕的情况下，执行这个算法的消耗时间**， 如在一个数组中查钊一个元素，这个元素正好在最后一个。

**平均时间复杂度**