### 定义
> 发布订阅模式又叫观察者模式。它定义对象间的一对多的依赖关系，当一个对象的状态发生变化时，所有订阅它的对象都将收到通知。**js中我们一般用事件模型来代替传统的观察者**


#### 应用场景
观察者模式在实际中有很多的应用场景，比如：
- 房产中介发的看房通知，中介是发布者，而你是订阅者。
- js中的DOM事件
- Node中的 EventEmitter 类

下面我们就实现一个自定义的 `EventEmitter`, 为了方便查看，我们只实现增加监听器和触发监听器的功能

```js
class EventEmmiter {
    constructor() {
        this.listenersMap = {};
    }

    // 监听器
    on(eventName, listener) {
        (eventName in this.listenersMap) ? this.listenersMap[eventName].push(listener): this.listenersMap[eventName] = [listener];
        return this;
    }

    // 添加单次监听器 listener 到名为 eventName 的事件。 当 eventName 事件下次触发时，监听器会先被移除，然后再调用。
    once(eventName, listener) {
        listener._once = true;
        (eventName in this.listenersMap) ? this.listenersMap[eventName].push(listener): this.listenersMap[eventName] = [listener];
        return this;
    }

    // 触发
    emit(eventName) {
        const args = [].slice.call(arguments, 1);
        this.listenersMap[eventName] && (this.listenersMap[eventName] = this.listenersMap[eventName].filter((listener, index) => {
            listener.apply(null, args);
            return !listener._once;
        }))
        return this;
    }

    // listeners
    listeners(eventName) {
        return this.listenersMap[eventName];
    }
}
var myEmitter = new EventEmmiter();
// 第一个监听器。
myEmitter.on('event', function firstListener() {
  console.log('第一个监听器');
});
// 第二个监听器。
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`第二个监听器中的事件有参数 ${arg1}、${arg2}`);
});
// 第三个监听器
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ');
  console.log(`第三个监听器中的事件有参数 ${parameters}`);
});
// 第4个监听器
myEmitter.once('event', function fouthListener(...args) {
  const parameters = args.join(', ');
  console.log(`once4 ${parameters}`);
});

// 第5个监听器
myEmitter.once('event', function fifthListener(...args) {
  const parameters = args.join(', ');
  console.log(`once5 ${parameters}`);
});

myEmitter.emit('event', 1, 2, 3, 4, 5); // 第一次调用时，所有的都会执行
myEmitter.emit('event', 1, 2, 3, 4); //  第二次执行时，只执行on注册的监听器，once注册的都已经被清理了

console.log(myEmitter.listeners('event'))
```