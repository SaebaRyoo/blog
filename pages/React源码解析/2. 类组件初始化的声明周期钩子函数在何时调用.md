# 未完成

### 类组件如何被创建

假设现在我们有如下组件
```js
  var container = document.getElementById("root");
  function A() {
    React.Component.call(this);
    this.state = {
      name: 'test'
    }
  }

  function _create(obj) {
    function F() {};
    F.prototype = obj;
    return new F();
  }

  function _inherits(subClass, superClass) {
    var prototype = _create(superClass.prototype);
    prototype.constructor = subClass;
    subClass.prototype = prototype;
  }

  _inherits(A, React.Component)

  A.prototype.componentDidMount = function() {
  }

  A.prototype.render = function() {
    return React.createElement("div", {onClick: () => this.setState({name: 'abc'})}, this.state.name);
  }

  var children = React.createElement(A, { className: "hello", identify: 'root-classA' });
  ReactDOM.render(children, document.getElementById("root"));
```

首先，我们在初始化创建了`RootFiber`和`FiberRoot`后，会进入`beginWork`，由于FiberRoot的tag类型是3，所以首先会进入`HostRoot`分支，并创建。然后会通过虚拟DOM生成新的Fiber，并挂到workInProgress.child上。然后就是先找child、然后是sibling节点。接下来就是一个同步渲染。再回到`beginWork`中，所有类型的组件都通过这里的`workInProgress.tag`进入不同组件的渲染.

在进行完 `RootFiber` 的任务后，就会创建一个 虚拟DOM的type为A的 子节点fiber,并且这时，这个fiber的tag为1。
这在`beginWork`中会进入 `ClassComponent`分支，然后执行 `updateClassComponent()`，**如果是首次渲染**，则首先会执行`constructClassInstance()`, 这个方法在将setState的原理时再说。

先说下一个方法 `mountClassInstance()`, 这个方法的作用就是执行类组件初始化阶段的所有钩子函数。

```js

function updateClassComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: any,
  nextProps,
  renderExpirationTime: ExpirationTime,
) {

  // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.
  let hasContext;
  if (isLegacyContextProvider(Component)) {
    hasContext = true;
    pushLegacyContextProvider(workInProgress);
  } else {
    hasContext = false;
  }
  prepareToReadContext(workInProgress, renderExpirationTime);

  const instance = workInProgress.stateNode;
  let shouldUpdate;
  if (instance === null) {
    if (current !== null) {
      // A class component without an instance only mounts if it suspended
      // inside a non-concurrent tree, in an inconsistent state. We want to
      // treat it like a new mount, even though an empty version of it already
      // committed. Disconnect the alternate pointers.
      // 没有实例的类组件只有在以非同步状态挂在非并发树中时才安装。 即使已经提交了空版本，我们也希望将其视为新的安装。 断开备用指针。
      current.alternate = null;
      workInProgress.alternate = null;
      // Since this is conceptually a new fiber, schedule a Placement effect
      workInProgress.effectTag |= Placement;
    }
    // 首次渲染
    // In the initial pass we might need to construct the instance.
    // 在最初的过程中，我们可能需要构造实例。
    constructClassInstance(workInProgress, Component, nextProps);
    // 在以前从未渲染过的实例上调用生命周期函数。
    mountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
    shouldUpdate = true;
  } else if (current === null) {
    // In a resume, we'll already have an instance we can reuse.
    // 已经有一个实例,且有对应的fiber
    shouldUpdate = resumeMountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  } else {
    shouldUpdate = updateClassInstance(
      current,
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  }
  const nextUnitOfWork = finishClassComponent(
    current,
    workInProgress,
    Component,
    shouldUpdate,
    hasContext,
    renderExpirationTime,
  );

  return nextUnitOfWork;
}


// ----------------------------------------------------



function mountClassInstance(
  workInProgress: Fiber,
  ctor: any,
  newProps: any,
  renderExpirationTime: ExpirationTime,
): void {

  const instance = workInProgress.stateNode;
  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;

  initializeUpdateQueue(workInProgress);

  const contextType = ctor.contextType;
  if (typeof contextType === 'object' && contextType !== null) {
    instance.context = readContext(contextType);
  } else if (disableLegacyContext) {
    instance.context = emptyContextObject;
  } else {
    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    instance.context = getMaskedContext(workInProgress, unmaskedContext);
  }

  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);
  instance.state = workInProgress.memoizedState;

  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  if (typeof getDerivedStateFromProps === 'function') {
    // 执行getDerivedStateFromProps钩子函数
    applyDerivedStateFromProps(
      workInProgress,
      ctor,
      getDerivedStateFromProps,
      newProps,
    );
    instance.state = workInProgress.memoizedState;
  }

  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if (
    typeof ctor.getDerivedStateFromProps !== 'function' &&
    typeof instance.getSnapshotBeforeUpdate !== 'function' &&
    (typeof instance.UNSAFE_componentWillMount === 'function' ||
      typeof instance.componentWillMount === 'function')
  ) {
    // 执行componentWillMount钩子
    callComponentWillMount(workInProgress, instance);
    // If we had additional state updates during this life-cycle, let's
    // process them now.
    processUpdateQueue(
      workInProgress,
      newProps,
      instance,
      renderExpirationTime,
    );
    instance.state = workInProgress.memoizedState;
  }

  if (typeof instance.componentDidMount === 'function') {
    // 更改fiber的effectTag为Update
    // 这里还没搞懂
    workInProgress.effectTag |= Update;
  }
}
```