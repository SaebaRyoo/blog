1. setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。
2. setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
3. setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。


### 为什么是异步的

https://github.com/facebook/react/issues/11527


1. 为了批量更新(batch updates) 延迟 `reconciliation` 是有益的，在多数情况下，同步setState是低效的。
比如，如果我们在浏览器点击处理程序中，并且子级和父级都调用`setState`,我们不想渲染两次子级，而是将它标记为脏，然后在退出浏览器事件之前再将它们一起重新渲染
2. 保持内部一致性
3. 允许并发更新，
    -  “异步渲染”的一种方式是，React可以setState()根据调用的来源分配不同的优先级：事件处理程序，网络响应，动画等。如果我们让某些更新具有“较低的优先级”，我们可以将它们的渲染分成几毫秒的小块，这样用户就不会注意到它们。
    