### 为什么传统上利用多个域名来提供网站资源会更有效
因为浏览器的网络进程在请求同一个域名的资源时，最多只能维持6个tcp持久连接，所以可以将资源放置在不同的服务器

### [Long-Polling、Websockets 和 Server-Sent Event](https://juejin.im/post/5b135b78f265da6e420eab7d#heading-5)

### [常见的请求头、响应头](https://juejin.im/post/5c17d3cd5188250d9e604628)

### [和缓存有关的HTTP首部字段](https://juejin.im/post/5a6eb7e06fb9a01c9a27014b)

### [HTTP method](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)

| 方法 | 作用 |
| - | -|
| [GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET) | GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据. |
| [HEAD](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD) | HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.|
| [POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)  | POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用. |
| [PUT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT) | PUT方法用请求有效载荷替换目标资源的所有当前表示。
| [DELETE](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE) | DELETE方法删除指定的资源。
| [CONNECT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT) | CONNECT方法建立一个到由目标资源标识的服务器的隧道。
| [OPTIONS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS) | OPTIONS方法用于描述目标资源的通信选项。
| [TRACE](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE) | TRACE方法沿着到目标资源的路径执行一个消息环回测试。
| [PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH) | PATCH方法用于对资源应用部分修改。

### [http响应码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)

### [https 加密过程](https://www.jianshu.com/p/2b89b7ac7c9d)
https://blog.csdn.net/clh604/article/details/22179907

### [http2新特性](https://www.jianshu.com/p/67c541a421f9)
多路复用
可以设置请求优先级
服务器推送
头部压缩

### XMLHttpRequest
```js
  var xhr = new XMLHttpRequest();
  xhr.open(method, url);

  xhr.onreadystatechange = function() {
    if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
      console.log(xhr.responseText)
    }
  }
  xhr.send();
```

### TCP/IP的三次握手四次挥手
SYN 表示建立连接，
FIN 表示关闭连接，
ACK 表示响应，
PSH 表示有
DATA 数据传输，
RST 表示连接重置。

SYN_SENT 状态表示请求连接
SEND_RCVD 服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态
ESTABLISHED 的意思是建立连接。表示两台机器正在通信。
CLOSE_WAIT 对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭
TIME_WAIT  我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT

RST表示连接重置。
**三次握手**
1. 客户端发起SYN_SENT, 发送SYN=1、seq=k（seq为随机数）请求连接
2. 服务器确认SEND_RCVD， 并针对客户端的SYN进行应答，发送SYN=1、 ACK=1、ack=k+1、seq=j（seq为随机数），建立请求连接；
3. 客户端ESTABLISHED,并针对服务器SYN进行应答,发送ACK=1， ack=j+1。服务器接收到ACK，进入ESTABLISHED 状态，连接建立完成

**四次挥手**
1. 客户端状态进入FIN_WAIT=1，发送FIN=M，用来关闭客户端到服务器的数据传送
2. 服务器针对客户端的FIN应答，发送ack=M+1，状态改为CLOSE_WAIT，表示服务器已经接收到关闭请求，但是没有做好准备，然后客户端状态变为FIN_WAIT=2；
3. 服务器发送FIN=N，表示服务器确定数据已经发送完毕。告诉客户端，已准备好关闭连接。服务器状态改为LAST_ACK。
4. 客户端接收FIN_N报文后，知道可以关闭连接，但它爬服务器不知道要关闭，所以还是需要发送ACK=1、ack=N+1。然后进入TIME_WAIT，如果服务端收到ACK后，则就知道可以断开了。客户端等待2MSL 后依然没收到回复，则服务器正常关闭


### HTTPS

https采用对称加密和非对称加密+数字证书的方式，对传输数据进行加密

**对称加密方式如下**
1. 客户端发送加密套件列表（就是客户端支持的加密方式）+ client-random
2. 服务器从加密套件中选择一个加密方式，并生成service-random + 新的加密套件返回给客户端
3. 最后浏览器和服务器分别返回确认消息

这样浏览器和服务器都有相同client-random和service-random，然后再使用相同的方法混合起来生成一个master-secret。
有了master-secret和加密套件后，双方就可以进行数据的加密传输了。

但是由于client-random和service-random是明文的。意味着中间人也可以拿到加密套件和双方随机数。由于利用随机数合成密钥的算法是公开的，所以中间人拿到随机数后，也可以合成密钥，然后破解数据


**非对称加密**
1. 首先浏览器会发送加密套件列表给服务器
2. 服务器会选择一个加密方式，和对称加密不同的是，使用非对称加密时，服务器上需要有用于浏览器加密的公钥和服务器解密的私钥。由于公钥是给浏览器加密用的，因此服务器会将加密套件和公钥一起发送给浏览器。

这样在浏览器向服务器发送数据时，就可以使用公钥来加密数据。由于公钥加密只有私钥才能解密，所以即使黑客截获了数据和公钥，他也无法获取数据。

但是有以下的缺点
- 非对称加密效率太低。严重影响到解密数据的数据，进而影响到用户打开页面的速度。
- 无法保证服务器发送给浏览器的数据安全。虽然浏览器端可以使用公钥来加密，但是服务器只能私钥加密。因此，当服务器发送数据和公钥的时候，中间人也是可以获取到公钥和私钥加密的数据的。这样就无法保证服务器端发送的数据安全。

**对称加密和非对称加密搭配使用**
相比较对称加密和非对称加密，采用两者相结合的方式则更加完美。**使用对称加密来传输数据，使用非对称加密来传输对称加密的密钥**。

![](../../assets/https.png)

1. 首先浏览器端会发送client-random、对称加密列表、非对称加密列表给服务器端
2. 服务器端选择并发送对称加密方式、非对称加密方式、service-random和公钥给浏览器端
3. 然后浏览器会生成一个随机数pre-master、然后通过非对称加密的方式。使用公钥加密pre-master给服务器端。（需要注意，pre-master是通过非对加密的公钥加密的，所以黑客是无法获取到私钥来解密数据的。）
4. 服务器端接收到使用公钥加密的pre-master，然后使用私钥解密获取到pre-master。（到此，浏览器端和服务器端都有了client-random、service-random、pre-master）
5. 使用 client-random、service-random、pre-master生成的**master secret**加密传输数据。

**添加数字证书**
虽然使用对称和非对称混合加密的方式，完美的实现了数据的加密传输。但是黑客可以通过DNS劫持将网站的ip换成自己的ip。这样，对于用户来说，其实访问的就是黑客的服务器了。黑客就可以在自己的服务器上实现公钥和私钥。对于浏览器而言，它完全不知道现在在访问黑客的站点。

所以需要有个第三方的权威机构来向浏览器证明“服务器”就是服务器。比如，买了房子，需要证明这个房子是你的。那么这里的房管局就是一个**第三方权威机构**。而房产证就是**证书**。

同理，网站A要证明服务器就是网站A的，也需要一个权威机构来颁发证书。这个权威机构就是**CA(Certificate Authority)**，颁发的证书就是**数字证书（Digital Certificate)**。

对于浏览器来说，数字证书的作用就是：1、通过证书向浏览器证明身份。2、包含服务器的公钥。

所以，包含了数字证书的https，与“对成与分对称结合”的方法相比，改变了如下两点：
1. 服务器不返回公钥，而是数字证书。
2. 客户端会多一个数字证书检验的过程，检验完成后才继续下面的流程

这样就算是黑客仿造了服务器，但是由于数字证书是无法仿造的。所以依然无法欺骗客户端（用户）