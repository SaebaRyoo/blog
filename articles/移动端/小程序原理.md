### 冷启动 热启动
冷启动： 小程序首次打开，或者是被微信或者用户销毁再次打开，需要重新加载。如果小程序在冷启动时发现新的版本，将会异步下载新版本的代码包，并且同时用客户端本地的代码包启动。也就是需要在下一次冷启动时才能使用新的版本。或者使用`wx.getUpdateManager`这个接口进行处理
热启动： 假如小程序已经打开过一次，在一定时间内（5分钟）再次打开，只是将后台的小程序切换到了前台，无需重新启动


### 双线程架构

- View 视图线程
- APP Service 逻辑线程

底层都通过weixinJSBridge进行通信的。

1. 视图的持续更新如何实现？

在小程序底层webview上有个`evaluateJavascript`方法。程序里的视图层和逻辑线程的数据传输就是通过这个原生的`evaluateJavascript`来实现的。setData要求更新的数据首先会将数据转化为字符串，再与代码拼接成一个JS脚本，最后把拼接的内容传给这个方法执行
```java
webview.evaluateJavascript('javascript:方法名()') {
    new ValueCallback<String>() {
        @Override
        public void onReceiveValue(String value) {
            ...
        }
    }
}
```


2. 使用setData会遇到什么问题
两个线程通过setData驱动数据交换，还需要通过`weixinJSBridge`进行中转，这个中转的效率非常低下，所以安卓用户在界面中进行滑动时会感到卡顿，这是因为视图线程一直在渲染中，逻辑层发来的更新请求被阻塞了，当这种阻塞>=200ms时，页面就会感觉到卡顿，机器性能越差，卡顿越明显。卡顿不仅和更新频率有关，和更新的数据量也有关。当更新一个大列表数据时，或者一个size比较大的图片时，也会容易产生卡顿。在IOS中，页面是由多个WKWebView组成的，当系统内存紧张时，会回收掉一部分WkWebView。所以曾经打开的页面会被清除出历史记录，无法回退。


3. 微信为什么要造WXS？

WXS结合WXML可以构建出页面的组件结构，WXS不依赖于运行时的基础库版本。与js不同，有自己的语法

**优点**
WXS不运行在逻辑线程，而是直接在视图线程，所以没有数据更新的平静过，相对较快

**缺点**
- 运行环境与其他js代码隔离，也无法访问wx api
- wxs函数不能作为视图模板中的时间回调句柄
- 由于环境的差异，在ios设备上wxs比js快2-20倍，但是在android中，没有差异


### 总结

1. 小程序采用双线程架构，视图线程和逻辑线程
2. 由于双线程的数据交互存在性能瓶颈，微信引入了WXS，在视图线程中执行逻辑。一般开发中，在onLoad之前，将后端初始化数据塞到Data中，用户初始化渲染，后续的视图交互与更新，如果不与后台数据相关，就用WXS语言，直接在视图中进行完成，增加效率