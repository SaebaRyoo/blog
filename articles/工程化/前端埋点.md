
### [js埋点方案](http://unclechen.github.io/2017/12/24/JS%E5%9F%8B%E7%82%B9%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/)
1. 手动埋点
    - 也就是代码埋点，通过引入SDK，主动调用方法进行数据上报。代码侵入大，在时间充分的情况下是首选
2. 无痕埋点
    - 通过实现JS SDK。对整个文档的可点击元素如: `a、img、button`等进行事件监听，并上报。但是这个方法非常的暴力，会产生大量的无用数据。建议一些按钮不多，页面相对简单的页面使用。而且应该后台配合进行数据过滤。

3. 可视化埋点（可视化也是上报全量点击数据，只是在后台根据可视化配置过滤出实际的数据）
    - 标记元素，保存配置：这一步要保存好需要追踪的元素的element_path，以及需要追踪的元素。
    - 下发配置，查找元素，监听点击，上报行为：这一步要通过element_path找到元素，给它添加一个点击监听器，当点击事件发生时SDK上报事件。

| 埋点方案	| 优点	| 缺点	| 适用场景
| - | - | - | - | 
代码埋点 | 	可以按照业务上报详细、定制化的数据	| 需要开发人员参与，更新维护成本高，无法获得历史数据	|  对上下文理解要求较高的业务数据
全埋点	| 对发人员依赖低，仅需嵌入一次SDK，可以全量上报通用数据，可以拿到历史数据	| 数量量太大，占用更多资源，且无法收集业务上下文数据，给后续数据筛选和分析带来一定的难度 | 	上下文相对独立的、通用的数据 | 
可视化埋点	| 对开发人员依赖低，可以按照业务需求上报数据，对上下文数据有一定收集能力 | 	标记事件有一定的操作难度，事件需要被更新时无法获得历史数据，界面变化时标记的元素可能失效 | 	业务上下文数据相对简单，操作交互比较固定的界面


### 埋点数据收集

- 事件基本数据
  - 事件发生事件
  - 发生时页面信息快照

- 页面相关
  - 页面PV， UV
  - 用户停留时长
  - 页面跳转事件
  - 页面进入后台
  - 用户离开页面

- 用户信息
  - 用户 uid
  - 用户设备指纹
  - 设备信息
  - ip
  - 定位

- 用户操作行为
  - 用户点击
    - 点击目标

- 页面 AJAX 请求
  - 请求成功
  - 请求失败
  - 请求超时

- 页面报错
  - 资源加载报错
  - JS 运行报错

- 资源加载新性能
- 图片
- 脚本
- 页面加载性能